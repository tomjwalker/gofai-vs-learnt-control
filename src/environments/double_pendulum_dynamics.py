# double_pendulum_dynamics.py
# Generated by sympy_inverted_double_pendulum.py

import casadi as ca
import numpy as np

def get_dynamics_function():
    """Creates and returns a CasADi Function for the derived dynamics."""

    # --- Define Symbolic Variables ---
    state = ca.SX.sym('state', 6)
    control = ca.SX.sym('control', 1)
    params = ca.SX.sym('params', 15)

    # --- Unpack Variables ---
    # State variables (6)
    x = state[0]
    theta1 = state[1]
    theta2 = state[2]
    x_d = state[3]
    theta1_d = state[4]
    theta2_d = state[5]
    # Control variables (1)
    U = control[0]
    # Parameters (15)
    M = params[0]
    m1 = params[1]
    m2 = params[2]
    l1 = params[3]
    l2 = params[4]
    d1 = params[5]
    d2 = params[6]
    Icm1 = params[7]
    Icm2 = params[8]
    g = params[9]
    b_slide = params[10]
    b_fric = params[11]
    b_joint1 = params[12]
    b_joint2 = params[13]
    gear = params[14]

    # --- Define State Derivatives ---
    x_dot = x_d
    theta1_dot = theta1_d
    theta2_dot = theta2_d
    x_ddot = 1.0*(U*gear - b_fric*x_d - b_slide*x_d + d1*m1*theta1_d**2*ca.sin(theta1) + d2*m2*theta2_d**2*ca.sin(theta2) + l1*m2*theta1_d**2*ca.sin(theta1))/M
    theta1_ddot = 1.0*(-b_joint1*theta1_d + d1*g*m1*ca.sin(theta1) - d2*l1*m2*theta2_d**2*ca.sin(theta1 - theta2) + g*l1*m2*ca.sin(theta1))/Icm1
    theta2_ddot = 1.0*(-b_joint2*theta2_d + d2*g*m2*ca.sin(theta2) + d2*l1*m2*theta1_d**2*ca.sin(theta1 - theta2))/Icm2

    # Assemble state derivative vector
    state_dot = ca.vertcat(x_d, theta1_d, theta2_d, x_ddot, theta1_ddot, theta2_ddot)

    # --- Create CasADi Function ---
    dynamics_func = ca.Function(
        'double_pendulum_dynamics_ode',
        [state, control, params],
        [state_dot],
        ['state', 'control', 'params'],
        ['state_dot']
    )

    return dynamics_func


if __name__ == '__main__':
    print("Testing the generated CasADi function...")
    dynamics = get_dynamics_function()
    print("Function created:", dynamics)

    n_state = 6
    n_control = 1
    n_params = 15

    # Example state (adjust as needed)
    state_val = np.zeros(n_state)
    # Example control
    control_val = np.zeros(n_control)
    # Example parameters (MUST match order defined in generation script)
    param_name_list_str = "Parameter order: ['M', 'm1', 'm2', 'l1', 'l2', 'd1', 'd2', 'Icm1', 'Icm2', 'g', 'b_slide', 'b_fric', 'b_joint1', 'b_joint2', 'gear']"
    print(param_name_list_str)
    # Provide a default array based on expected length
    param_val = np.ones(n_params) 
    # You SHOULD replace this with actual default/test values
    print(f"Using placeholder parameters: {param_val}")

    if len(param_val) != n_params:
        raise ValueError(f"Incorrect number of parameters provided. Expected 15, got {len(param_val)}.")

    try:
        state_dot_val = dynamics(state_val, control_val, param_val)
        print("State vector (example):", state_val)
        print("Control vector (example):", control_val)
        print("Calculated state_dot:", state_dot_val)
    except Exception as e:
        print("Error during function evaluation:", e)
        import traceback
        traceback.print_exc()

